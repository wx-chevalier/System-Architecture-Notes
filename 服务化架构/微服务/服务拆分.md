# 微服务的设计原则

在实践微服务软件架构之初，一开始大家所关注的焦点是“如何拆”、“拆多大”以及技术与组织架构的配称（康威定律），核心思路是通过将单体应用通过分拆去变成更小的软件发布单元，以解决单体应用的软件迭代速度慢的问题（背后导致了商业价值创造慢的后果）。然而，当微服务改造工作完成且微服务的个数达到一定的规模时，各服务之间的连接、排错、安全保障、监控等问题就逐渐地浮出了水面，那时行业深刻地体会并认识到微服务软件架构其实是将复杂度从单体应用内转移到了微服务之间。随着分布式应用规模的进一步增大，所涉开发和运维人员增长到一定数据时，效率问题再一次变得像单体应用时代那样不可小视。不过，这一次所面临的问题域和规模比那时大了很多。要解决微服务软件架构所带来的新问题，需要探索更加体系化、规范化和全局一致的解决方案，那就不可避免地会采用新的概念切分手法去构建新的解决方案，期间不可并避免地会打破旧概念并创造出新概念。在微服务设计中，我们同样需要遵循中如[《架构设计原则》](https://ng-tech.icu/SoftwareEngineering-Series/?q=架构设计原则)中高内聚低耦合、复用、单一职责等设计原则。

# 服务的定义

服务怎么定义呢？需要从应用开发者角度看待怎么定义服务。服务在功能维度对应某一功能，如查询已买订单详情。在 Dubbo 中，对应某个接口下的方法；在 Spring Cloud 和 gRPC 对应一个 http 请求。如果从面向函数编程角度，一个服务就是一个 function。在 Java 语言中，class 是一切编程的基础，所以将某些服务按照一定的维度进行聚合，放到某个接口中，就成了一个接口包含了很多的服务。从 Dubbo 角度来解释下：Dubbo 是面向接口编程的远程通信，所以 Dubbo 是面向服务集的编程，你如果想调用某个服务，必须通过接口的方式引入，然后调用接口中的某个服务。Dubbo Ops 中提供的服务查询功能，其实不是查询单个服务，而是通过查询接口（服务集）之后获得具体的方法（服务）。

而在 Spring Cloud 的世界里，服务提供方会将自己的应用信息（IP + port）注册成应用下的一个实例，服务消费方和服务提供方按照约定的形式进行 Rest 请求。每个请求对应的也是一个服务。Kubernetes 里的 Service 其实是对应到一组 Pod + port 列表，和 DNS 联系紧密；用通俗易懂的方式表达：维护了 Pod 集合的关系映射。和上面讲的服务是属于不同场景下的两个概念。

一个应用下包含了很多接口，一个接口下包含了很多服务（Dubbo）；或者一个应用包含了很多的服务（Spring Cloud）。按照这个方式定义服务，服务治理的粒度其实也是按照服务粒度，可以针对每个服务设置超时时间，设置路由规则等等。

# 领域驱动

微服务设计首先应建立领域模型，确定逻辑和物理边界后，然后才进行微服务边界拆分，而不是一上来就定义数据库表结构，也不是界面需要什么，就去调整领域逻辑代码。领域模型和领域服务应具有高度通用性，通过接口层和应用层屏蔽外部变化对业务逻辑的影响，保证核心业务功能的稳定性。

# 边界与职能清晰

微服务完成开发后其功能和代码也不是一成不变的。随着需求或设计变化，微服务内的代码也会分分合合。逻辑边界清晰的微服务，可快速实现微服务代码的拆分和组合。DDD 思想中的逻辑边界和分层设计也是为微服务各种可能的分分合合做准备的。微服务内聚合与聚合之间的领域服务以及数据原则上禁止相互产生依赖。如有必要可通过上层的应用服务编排或者事件驱动机制实现聚合之间的解耦，以利于聚合之间的组合和拆分。

分层架构中各层职能定位清晰，且都只能与其下方的层发生依赖，也就是说只能从外层调用内层服务，内层服务通过封装、组合或编排对外逐层暴露，服务粒度由细到粗。应用层负责服务的编排和组合，领域层负责领域业务逻辑的实现，基础层为各层提供资源服务。

# 避免过度拆分

微服务的过度拆分必然会带来软件维护成本的上升，如：集成成本、运维成本以及监控和定位问题的成本。企业转型过程中很难短时间内提升这些能力，如果项目团队不具备这些能力，将很难 hold 住这些过细的微服务。而如果我们在微服务设计之初就已经定义好了微服务内的逻辑边界，项目初期我们可以尽可能少的拆分出过细的微服务，随着技术的积累和时间的推移，当我们具有这些能力后，由于微服务内有清晰的逻辑边界，这时就可以随时根据需要轻松的拆分或组合出新的微服务。

# TBD

- https://mp.weixin.qq.com/s/rxprDWMTyBr1I_TnTgV2JA
